Харківський національний університет радіоелектроніки
Факультет комп’ютерних наук
Катедра програмної інженерії


ЗВІТ
до лабораторної роботи №2
з дисципліни «Аналіз та рефакторинґ коду»
на тему: «РОЗРОБКА БАЗИ ДАНИХ ДЛЯ СЕРВЕРНОЇ ЧАСТИНИ ПРОГРАМНОЇ СИСТЕМИ ТА ПРИКЛАДНОГО ПРОГРАМНОГО ІНТЕРФЕЙСУ (API)»


Виконала
ст. гр. ПЗПІ-23-3 
Давиденко Поліна
Перевірив
ст. викладач катедри ПІ
Сокорчук Ігор Петрович

Харків 2025
1 ІСТОРІЯ ЗМІН
№ДатаВерсія звітуОпис змін та виправлень125.11.20250.1Створено розділ «Завдання»203.12.20250.2Створено розділ «Опис Виконаної роботи»304.12.20250.3Завершено розділ «Опис Виконаної роботи»


2 ЗАВДАННЯ
1. Розробити будову програмної системи:
* Сформулювати архітектурні рішення для серверної частини системи, клієнтських взаємодій та БД.
* Описати моделі, що використовуються в системі, та зв'язки між ними.
2. Створити UML діаграму прецедентів для серверної частини системи:
* Використовуйте UML для опису основних прецедентів використання серверної частини. Діаграма повинна включати дії користувачів та взаємодії між ними та системою.
3. Створити ER діаграму даних:
* Визначте сутності, атрибути та зв’язки між ними у вашій БД. Використовуйте ER діаграму для наочного відображення структури даних.
4. Розробити базу даних (БД) програмної системи:
* На основі ER діаграми спроєктуйте таблиці БД.
* Описати схему нормалізації даних (1NF, 2NF, 3NF).
5. Створити діаграму структури БД:
* Діаграма повинна показувати всі таблиці, зв’язки між ними, ключові поля та обмеження.
6. Розробити функції роботи з БД (ORM або CoRM тощо):
* Реалізуйте методи доступу до БД, використовуючи ORM (Object-Relational Mapping) або CoRM (Custom ORM).
* Функції повинні підтримувати CRUD-операції (Create, Read, Update, Delete) для основних сутностей.
7. Розробити API для взаємодії серверної частини з клієнтами:
* Визначте, який тип API буде використовуватися: REST, GraphQL або gRPC.
* Описати ендпоінти, які будуть реалізовані в API, їхні методи (GET, POST, PUT, DELETE) та параметри.
8. Створити специфікацію розробленого API:
* Специфікація повинна містити:
• Опис кожного ендпоінту.
• Формат запитів та відповідей.
• Приклади використання API.
9. Створити програмну реалізацію API та функцій роботи з БД:
* Реалізуйте серверну частину системи із доступом до БД та можливістю обробки запитів через API.
* Перевірте коректність роботи API та його взаємодію з БД.
10. Перевірити роботу створеного програмного коду серверної частини системи:
* Проведіть тестування розроблених функцій, зокрема перевірте взаємодію API з БД.



3 ОПИС ВИКОНАНОЇ РОБОТИ
	3.1. Архітектурні рішення для серверної частини, клієнтських взаємодій та бази даних
	Програмна система SmartFood будується на основі клієнт–серверної архітектури, де логіка програми розділена на три рівні: клієнтський інтерфейс, серверна частина та база даних.
	Серверна частина (Back-end) відповідає за:
* обробку HTTP-запитів клієнтів;
* перевірку коректності отриманих даних;
* виконання бізнес-логіки (створення замовлення, обробка меню, оновлення статусів);
* взаємодію з базою даних.
	Для реалізації серверної частини обрано Python з використанням фреймворку Flask.
	Сервер взаємодіє з базою даних за допомогою ORM SQLAlchemy, що забезпечує зручність роботи з сутностями та безпеку запитів.
	Клієнтська частина (Front-end) представлена вебінтерфейсом, який доступний через браузер. Функції клієнта:
* перегляд меню;
* формування кошика;
* створення замовлення;
* перегляд статусу замовлення;
* виклик офіціанта.
	Для реалізації передбачено використання HTML/CSS/JS, взаємодія з сервером через REST API, формат обміну - JSON.
	Для зберігання структурованих даних використовується реляційна база даних Microsoft SQL Server. У БД зберігаються дані користувачів, інформація про меню, категорії страв, замовлення, позиції замовлень, статуси, інформація про столики. База даних складається з декількох взаємопов’язаних таблиць. Зв’язки між даними реалізовані за допомогою зовнішніх ключів.

	3.2 Опис моделей, що використовуються в системі, та їх зв’язків
	Нижче подано логічний опис основних моделей системи SmartFood та ролі кожної з них.
	User (Користувач). Представляє всіх користувачів системи: адміністратора, офіціанта, кухаря. Основні поля: ім’я, email, пароль, роль. Користувач відповідає за дії у системі: створення меню (адмін), перегляд активних замовлень (кухня), обслуговування (офіціант). Зв’язки: User → Role (багато до одного).
	Role (Роль користувача). Модель визначає типи користувачів: admin, waiter, kitchen. Забезпечує розмежування доступу та дозволів.
	Dish (Страва). Представляє окрему страву меню з назвою, описом, ціною та категорією. Відображається клієнту у меню, додається до замовлення. Зв’язки: Dish → Category (багато до одного).
	Category (Категорія страв). Містить категорії меню: сніданки, супи, салати, напої. Категорія допомагає структурувати меню. 
	Table (Столик у залі). Фізичний столик у ресторані, за яким сидить клієнт. Має унікальний номер, кількість місць та прив’язується до офіціанта, який обслуговує цей столик. Зв’язки: Table → User (багато до одного).
	Order (Замовлення). Одна дія клієнта - сформоване замовлення, яке включає кілька страв, час створення, статус. Основні статуси: created, cooking, ready, delivered, paid. Зв’язки: Order → Table (багато до одного).
	OrderItem (Позиція замовлення). Окрема страва в складі замовлення з кількістю та посиланням на Dish. Дозволяє одному замовленню мати багато страв. Зв’язки: OrderItem → Order (багато до одного), OrderItem → Dish (багато до одного).

	3.3 UML діаграми прецедентів
	 Чотири актори: Client (Клієнт), Waiter (Офіціант), Cook (Кухар), Admin (Адміністратор).
	Клієнт взаємодіє із системою через вебінтерфейс без необхідності проходження авторизації. Він має можливість переглядати актуальне меню, сформоване адміністратором, додавати страви у кошик та створювати замовлення, яке передається на обробку серверу. Після створення замовлення клієнт може переглядати його статус у реальному часі, відповідно до змін, які виконують кухня та офіціант. Також клієнт має можливість викликати офіціанта через спеціальний інтерфейс. (див. рис. 3.1).	
	Офіціант входить у систему за допомогою авторизації, після чого отримує доступ до списку столиків, які за ним закріплені. Він може переглядати активні замовлення цих столиків, а також деталі кожного замовлення. У разі виклику клієнта офіціант отримує відповідне сповіщення. Також офіціант оновлює статуси замовлень на етапі доставки страви (див. рис. 3.2).
	Кухар також проходить авторизацію. Після входу він отримує список замовлень, які надійшли до кухні. Кухар може розпочати приготування певного замовлення, змінюючи статус на "cooking", а після завершення приготування оновити його до "ready". Ці статуси відображаються офіціантам і клієнтам (див. рис. 3.3).
	Адміністратор авторизується у системі та має доступ до повного набору інструментів управління. Він може створювати та редагувати елементи меню, додавати або оновлювати категорії страв, а також створювати та керувати обліковими записами персоналу офіціантів і кухарів (див. рис. 3.4).

Рисунок 3.1 – UML-діаграма для клієнта

Рисунок 3.2 – UML-діаграма для офіціанта


Рисунок 3.3 – UML-діаграма для кухаря

Рисунок 3.4 – UML-діаграма для адміністратора

		3.4 ER діаграма даних
		База даних програмної системи SmartFood складається з кількох логічно пов’язаних таблиць: «Роль», «Користувач», «Категорія», «Страва», «Столик», «Замовлення» та «Позиція_замовлення». Кожна таблиця виконує окрему функцію в межах роботи ресторанної системи, а зв’язки між ними забезпечують цілісність даних та коректну взаємодію між різними частинами застосунку.
		Таблиця «Роль» зберігає інформацію про тип користувача в системі та містить атрибут назви ролі. Через цю таблицю визначається, до якої категорії належить конкретний користувач - адміністратор, офіціант або кухар. Таблиця «Користувач» містить дані про всіх співробітників, які працюють із серверною частиною. Вона включає атрибути ім’я, номер телефона, електронну адресу та хешований пароль, а також містить зовнішній ключ, що посилається на таблицю «Роль». 
		Таблиця «Категорія» використовується для класифікації страв і містить назву категорії. Завдяки цьому меню може бути структуроване за типами страв: напої, салати, гарячі страви. Таблиця «Страва» описує кожну позицію меню та включає назву, опис, ціну та посилання на відповідну категорію. 
		Таблиця «Столик» зберігає інформацію про столики, що розміщені у залі. До неї входять такі атрибути, як номер столика та кількість місць, а також зовнішній ключ, що вказує на користувача-офіціанта, який обслуговує цей столик. 
		Таблиця «Замовлення» описує кожне окреме замовлення, здійснене клієнтом. Вона містить дату та час створення, загальну суму замовлення та статус, який може змінюватися кухарем або офіціантом залежно від етапу виконання: «створено», «готується», «готове», «доставлено» або «оплачено». Замовлення прив’язується до конкретного столика.
		Таблиця «Позиція_замовлення» містить деталі кожної окремої страви в складі замовлення. Вона включає кількість, ціну за одиницю на момент оформлення, а також загальну суму для цієї позиції. У цій таблиці використовується складений первинний ключ, що складається з «order_id» та «dish_id», що забезпечує унікальність кожної страви в межах одного замовлення та усуває можливість дублювання. 

Рисунок 3.5 – ER-діаграма

		3.4 Таблиці бази даних та нормалізація
		Для аналізу було обрано ключові сутності із загальної ER-діаграми: «Роль», «Користувач», «Категорія», «Страва», «Столик», «Замовлення» та «Позиція замовлення». Таким чином, до універсального відношення T включені такі атрибути: role_id, role_name, user_id, user_name, phone, email, password, category_id, category_name, dish_id, dish_name, description, price, table_id, number, seats, order_id, created_at, total_price, status, quantity, unit_price, total_item_price. Універсальне відношення наведено на рис. 3.6.

Рисунок 3.6 –  Універсальне відношення із визначеними  функціональними залежностями

		Відношення перебуває у першій нормальній формі (1НФ), якщо кожне його поле містить лише одне значення, тобто дані є атомарними, і жоден з рядків не має множинних значень у будь-якому атрибуті. Кожен запис таблиці унікально визначається первинним ключем, при цьому ключові поля не можуть бути порожніми, а порядок рядків не є визначеним. Для приведення атрибутів до першої нормальної форми необхідно визначити первинні ключі та встановити функціональні залежності між атрибутами.
		На рис. 3.6 стрілками позначено всі функціональні залежності, в тому числі залежність від первинного ключа відношення T, а також залежності між атрибутами. Первинним ключем є складена комбінація (order_id, dish_id), бо саме вона однозначно ідентифікує кожну позицію замовлення, тобто конкретну страву в межах конкретного замовлення. Жоден з атрибутів окремо, а також інші атрибути разом, не можуть забезпечити унікальність даних, оскільки лише поєднання ідентифікатора замовлення та ідентифікатора страви повністю визначає усі інші атрибути.
		Відношення знаходиться у другій нормальній формі (2NF) в тому та тільки в тому випадку, коли воно знаходиться у 1NF та кожен неключовий атрибут повністю функціонально залежить від первинного ключа відношення. У вихідному універсальному відношенні присутні часткові залежності, тому для досягнення другої нормальної форми було виконано декомпозицію відношення T на окремі таблиці: «Страва», «Замовлення» та «Позиція_замовлення». У результаті декомпозиції кожен неключовий атрибут тепер повністю залежить від свого первинного ключа, і залежності від частин складеного ключа усунуті. Таким чином, отримані таблиці знаходяться у 2NF. 
		Відношення знаходиться у третій нормальній формі (3NF) в тому та тільки в тому випадку, якщо воно знаходиться у 2NF та між неключовими атрибутами не існує транзитивних залежностей. У проєктованій схемі після декомпозиції транзитивні залежності було вилучено. Наприклад, атрибут category_name залежить від category_id, а не від dish_id або будь-яких інших неключових атрибутів. Аналогічно role_name залежить від role_id, а не від user_name чи інших атрибутів таблиці «Користувач». Після усунення транзитивних залежностей усі атрибути залежать виключно від відповідних первинних ключів своїх таблиць, що забезпечує відповідність третьої нормальної форми. Отже, розкладені таблиці перебувають у 3NF.
		На рис. 3.7 зображено результат побудови логічної моделі бази даних SmartFood, отриманої шляхом нормалізації універсального відношення.

Рисунок 3.7 –  Логічна модель бази даних

		3.5 Розробка функцій роботи з базою даних (ORM)
		Для реалізації доступу до бази даних у системі SmartFood використано ORM SQLAlchemy. ORM дозволяє працювати з таблицями бази даних як з класами та об’єктами, що спрощує реалізацію CRUD-операцій та забезпечує безпеку запитів без прямого використання SQL-інструкцій.
		Моделі відображають усі сутності бази даних: «Роль», «Користувач», «Категорія», «Страва», «Столик», «Замовлення», «Позиція замовлення» (Додаток Б.1).
		На поточному етапі реалізовані CRUD-функції (Create, Read, Update, Delete) для таких сутностей:
* Страва (Dish)
* Замовлення (Order)
* Позиція замовлення (OrderItem)
		Опрацювання решти сутностей («Користувач», «Столик», «Категорія», «Роль») наразі виконується у середовищі Microsoft SQL Server локально та перебуває на етапі інтеграції у серверний код.
		Об’єкт Dish містить інформацію про назву страви, опис, ціну та належність до категорії. Ці дані є базовими для формування меню на стороні клієнта.
Create (створення)
Функція створення нової страви забезпечує додавання її до меню:
def create_dish(name, description, price, category_id):
    dish = Dish(dish_name=name, description=description, price=price, category_id=category_id)
    db.session.add(dish)
    db.session.commit()
    return dish

Read (читання)
Отримання всіх страв меню або однієї позиції:
def get_all_dishes():
    return Dish.query.all()

def get_dish_by_id(dish_id):
    return Dish.query.get(dish_id)

Update (оновлення)
Допоміжна функція для редагування ціни, назви або опису:
def update_dish(dish_id, **kwargs):
    dish = Dish.query.get(dish_id)
    for key, value in kwargs.items():
        setattr(dish, key, value)
    db.session.commit()
    return dish

Delete (видалення)
Видалення страви з меню:
def delete_dish(dish_id):
    dish = Dish.query.get(dish_id)
    db.session.delete(dish)
    db.session.commit()

		Сутність Order є ключовою у системі, оскільки відображає створення замовлення, час його формування, статус виконання та загальну суму. Статуси реалізовані у вигляді ENUM.
Create (створення)
def create_order(table_id):
    order = Order(table_id=table_id, created_at=datetime.now(), status=OrderStatus.created, total_price=0)
    db.session.add(order)
    db.session.commit()
    return order
Read (читання)
def get_order_by_id(order_id):
    return Order.query.get(order_id)

Update (оновлення статусу)
def update_order_status(order_id, status):
    if status not in OrderStatus._value2member_map_:
        raise ValueError("Некоректний статус замовлення")

    order = Order.query.get(order_id)
    order.status = OrderStatus(status)
    db.session.commit()
    return order

Обчислення загальної вартості
def calculate_total(order_id):
    items = OrderItem.query.filter_by(order_id=order_id).all()
    total = sum(item.total_item_price for item in items)
    order = Order.query.get(order_id)
    order.total_price = total
    db.session.commit()
    return order.total_price

		Сутність OrderItem містить інформацію про окрему страву всередині замовлення: кількість, ціну за одиницю та підсумкову вартість.
Create (створення позиції)
def add_order_item(order_id, dish_id, quantity, unit_price):
    total_item_price = unit_price * quantity
    item = OrderItem(order_id=order_id, dish_id=dish_id,
                     quantity=quantity, unit_price=unit_price,
                     total_item_price=total_item_price)
    db.session.add(item)
    db.session.commit()
    return item

Read (отримання усіх позицій замовлення)
def get_items_by_order(order_id):
    return OrderItem.query.filter_by(order_id=order_id).all()

Delete (видалення позиції)
def delete_order_item(order_id, dish_id):
    item = OrderItem.query.get((order_id, dish_id))
    db.session.delete(item)
    db.session.commit()

		3.6 Розробка API для взаємодії серверної частини з клієнтами
		Для інтеграції клієнтської та серверної частини системи SmartFood обрано архітектурний підхід REST API. REST передбачає використання стандартних HTTP-методів (GET, POST, PUT, DELETE) та передачу даних у форматі JSON, що забезпечує простоту обміну інформацією та сумісність з будь-якими фронтенд-клієнтами.
		REST API використовується як основний спосіб взаємодії:
* клієнта з меню та замовленнями,
* офіціанта із закріпленими столиками та замовленнями,
* кухаря зі статусами виконання,
* адміністратора з управлінням меню.
		На даному етапі реалізовано основні ендпоінти роботи з меню та замовленнями, що дозволяють здійснювати формування та контроль процесу обслуговування клієнтів.
		Нижче наведено перелік основних ендпоінтів та їх призначення.


ЕндпоінтМетодПризначення/api/menuGETОтримання переліку страв меню/api/order/createPOSTСтворення нового замовлення/api/order/<id>GETОтримання інформації про конкретне замовлення/api/order/<id>/add-itemPOSTДодавання страви до замовлення/api/order/<id>/statusPUTОновлення статусу замовлення/api/order/<id>/itemsGETПерегляд позицій, що входять до замовлення/api/order/<id>/totalGETОбчислення підсумкової вартості замовлення/api/order/<id>/delete-itemDELETEВидалення певної страви із замовлення
3.7  Специфікація розробленого API
		У даному розділі представлена деталізація реалізованих ендпоінтів, форматів запитів і відповідей, а також приклади їх використання.
1. Отримання меню
Опис: Повертає перелік усіх страв, доступних у меню. 
URL: /api/menu
HTTP-метод: GET
Приклад відповіді:
[
    {
        "dish_id": 1,
        "dish_name": "Капучіно",
        "price": 70.0,
        "description": "Еспресо з молочною піною"
    },
    {
        "dish_id": 2,
        "dish_name": "Американо",
        "price": 60.0,
        "description": "Чорна кава"
    }
]

2. Створення замовлення
Опис: Ініціює нове замовлення для вибраного столика.
URL: /api/order/create
HTTP-метод: POST
Приклад запиту:
{
  "table_id": 4
}

Приклад відповіді:
{
  "order_id": 10,
  "status": "created"
}

3. Додавання страви до замовлення
Опис: Додає обрану страву до замовлення. Система автоматично підтягує ціну з таблиці «Страва» та обчислює загальну суму позиції.
URL: /api/order/{order_id}/add-item
HTTP-метод: POST
Приклад запиту:
{
  "dish_id": 3,
  "quantity": 2
}
Приклад відповіді:
{
  "message": "Страву додано",
  "dish_id": 3,
  "unit_price": 120.0,
  "total_item_price": 240.0
}

4. Перегляд позицій у замовленні
Опис: Повертає повний перелік доданих страв, їх кількість та розраховану суму.
URL: /api/order/{order_id}/items
HTTP-метод: GET
Приклад відповіді:
[
  {
    "dish_id": 3,
    "quantity": 2,
    "unit_price": 120,
    "total_item_price": 240
  }
]

5. Оновлення статусу замовлення
Опис: Доступно для офіціанта або кухаря. Дозволяє змінити стан замовлення (наприклад, «готується», «готове», «доставлено»).
URL: /api/order/{order_id}/status
HTTP-метод: PUT
Авторизація: передбачена у майбутній реалізації
Приклад запиту:
{
  "status": "ready"
}

Приклад відповіді:
{
  "order_id": 10,
  "new_status": "ready"
}

6. Перегляд інформації про замовлення
Опис: Відображає загальну суму, поточний статус та номер столика.
URL: /api/order/{order_id}
HTTP-метод: GET
Приклад відповіді:
{
  "order_id": 10,
  "table_id": 4,
  "status": "cooking",
  "total_price": 240.0
}

7. Розрахунок загальної суми
Опис: Повертає фінальну суму замовлення. Обчислення відбувається на серверній частині на основі доданих страв.
URL: /api/order/{order_id}/total
HTTP-метод: GET
Приклад відповіді:
{
  "order_id": 10,
  "total_price": 240
}

8. Видалення позиції страви з замовлення
Опис: Дозволяє скасувати додану страву (наприклад, якщо клієнт передумав).
URL: /api/order/{order_id}/delete-item
HTTP-метод: DELETE
Приклад запиту:
{
  "dish_id": 3
}

Приклад відповіді:
{
  "message": "Позицію видалено",
  "dish_id": 3
}

4 ВИСНОВКИ
	У ході виконання лабораторної роботи було спроєктовано та реалізовано серверну частину програмної системи SmartFood, що забезпечує автоматизацію процесу замовлення страв у закладі харчування. На етапі проєктування створено архітектурну модель, UML–діаграми прецедентів взаємодії користувачів із системою, ER-діаграму бази даних та структурну модель таблиць. Нормалізацію даних виконано до третьої нормальної форми, що дозволило усунути дублювання та транзитивні залежності.
	На основі розробленої схеми сформовано базу даних у середовищі Microsoft SQL Server, а взаємодію з нею реалізовано за допомогою ORM SQLAlchemy. Було створено CRUD-функції для роботи з основними сутностями: «Страва», «Замовлення» та «Позиція замовлення». 
	Було розроблено REST API, що забезпечує повний цикл обробки замовлення: перегляд меню, створення замовлення, додавання й видалення позицій, відстеження статусу та розрахунок підсумкової вартості. Для документування та тестування API інтегровано Swagger UI, який надає наочний інтерфейс для виконання запитів та перевірки коректності результатів без необхідності використання клієнтських програм.

5 ВИКОРИСТАНІ ДЖЕРЕЛА
1. HTTP request methods - HTTP | MDN. MDN Web Docs. URL: https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Methods (date of access: 03.12.2025).
2. OpenAPI Specification - Version 3.1.0 | Swagger. API Documentation & Design Tools for Teams | Swagger. URL: https://swagger.io/specification/ (date of access: 03.12.2025).
3. SQLAlchemy Documentation – SQLAlchemy 2.0 Documentation. SQLAlchemy Documentation – SQLAlchemy 2.0 Documentation. URL: https://docs.sqlalchemy.org/en/20/ (date of access: 25.12.2025).
4. Welcome to Flask – Flask Documentation (3.1.x). Welcome to Flask – Flask Documentation (3.1.x). URL: https://flask.palletsprojects.com/en/stable/ (date of access: 25.12.2025).
5. 

ДОДАТОК А
Відеозапис
Відеозапис доповіді: https://youtu.be/BXWhF3kOZnE
Хронологічний опис відеозапису:
00:00 - представлення, вступ
00:16 - Архітектурні рішення для серверної частини
00:46 - UML діаграми прецедентів
01:40 - ER діаграма даних, таблиці бази даних та нормалізація
02:32 - Розробка функцій роботи з базою даних
03:53 - Розробка API для взаємодії серверної частини з клієнтами
04:32 - Специфікація розробленого API
05:00 - Тестування: Отримання переліку страв меню
05:18 - Тестування: Створення нового замовлення
06:00 - Тестування: Додавання страви до замовлення
06:39 - Тестування: Обчислення підсумкової вартості замовлення
06:46 - Тестування: Отримання інформації про конкретне замовлення
07:08 - Тестування: Оновлення статусу замовлення
07:50 - Тестування: Перегляд позицій, що входять до замовлення
08:36 - Тестування: Видалення певної страви із замовлення

ДОДАТОК Б
Програмний код
Б.1 Логіка взаємодії з БД
GitHub репозиторій: https://github.com/NureDavydenkoPolina/ark-pzpi-23-3-davydenko-polina/blob/main/Lab2/ark-pzpi-23-3-davydenko-polina-lab2/SmartFoodBackend/config.py
1.  from flask_sqlalchemy import SQLAlchemy
2.  from flask import Flask
3.  
4.  app = Flask(__name__)
5.  
6.  app.config["SQLALCHEMY_DATABASE_URI"] = (
7.      "mssql+pyodbc://DESKTOP-5GUF215\\SQLEXPRESS/SmartFood?driver=ODBC+Driver+18+for+SQL+Server&Trusted_Connection=yes&Encrypt=no"
8.  )
9.  
10. app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False
11. app.config["JSON_AS_ASCII"] = False
12. 
13. db = SQLAlchemy(app)

Б.2 Моделі
GitHub репозиторій: https://github.com/NureDavydenkoPolina/ark-pzpi-23-3-davydenko-polina/blob/main/Lab2/ark-pzpi-23-3-davydenko-polina-lab2/SmartFoodBackend/models/models.py
1  import enum
2  from config import db 
3  
4   class Role(db.Model): 
5       __tablename__ = "Role"
6   
7       role_id = db.Column(db.Integer, primary_key=True)
8       role_name = db.Column(db.String(50), nullable=False)
9   
10  class User(db.Model):
11      __tablename__ = "User"
12  
13      user_id = db.Column(db.Integer, primary_key=True)
14      user_name = db.Column(db.String(100), nullable=False)
15      phone = db.Column(db.String(20))
16      email = db.Column(db.String(120), unique=True)
17      password = db.Column(db.String(255), nullable=False)
18      role_id = db.Column(db.Integer, db.ForeignKey("Role.role_id"), nullable=False)
19  
20  class Category(db.Model):
21      __tablename__ = "Category"
22  
23      category_id = db.Column(db.Integer, primary_key=True)
24      category_name = db.Column(db.String(50), nullable=False)
25  
26  class Dish(db.Model):
27      __tablename__ = "Dish"
28  
29      dish_id = db.Column(db.Integer, primary_key=True)
30      dish_name = db.Column(db.String(100), nullable=False)
31      description = db.Column(db.String(255))
32      price = db.Column(db.Float, nullable=False)
33      category_id = db.Column(db.Integer, db.ForeignKey("Category.category_id"), nullable=False)
34  
35  class Table(db.Model):
36      __tablename__ = "Table"
37  
38      table_id = db.Column(db.Integer, primary_key=True)
39      number = db.Column(db.Integer, nullable=False)
40      seats = db.Column(db.Integer, nullable=False)
41      waiter_id = db.Column(db.Integer, db.ForeignKey("User.user_id"), nullable=False)
42  
43  class OrderStatus(enum.Enum):
44      created = "created"
45      cooking = "cooking"
46      ready = "ready"
47      delivered = "delivered"
48      paid = "paid"
49  
50  class Order(db.Model):
51      __tablename__ = "Order"
52  
53      order_id = db.Column(db.Integer, primary_key=True)
54      created_at = db.Column(db.DateTime)
55      total_price = db.Column(db.Float)
56      status = db.Column(db.Enum(OrderStatus), nullable=False, default=OrderStatus.created)
57      table_id = db.Column(db.Integer, db.ForeignKey("Table.table_id"), nullable=False)
58  
59  class OrderItem(db.Model):
60      __tablename__ = "OrderItem"
61  
62      order_id = db.Column(db.Integer, db.ForeignKey("Order.order_id"), primary_key=True)
63      dish_id = db.Column(db.Integer, db.ForeignKey("Dish.dish_id"), primary_key=True)
64      quantity = db.Column(db.Integer, nullable=False)
65      unit_price = db.Column(db.Float, nullable=False)
66      total_item_price = db.Column(db.Float, nullable=False)

2


